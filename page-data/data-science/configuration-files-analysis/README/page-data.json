{"componentChunkName":"component---src-templates-doc-js","path":"/data-science/configuration-files-analysis/README/","result":{"data":{"site":{"siteMetadata":{"title":"Operate First"}},"mdx":{"id":"553ce20e-8262-5fc9-8378-853aadf5596f","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Configuration file analysis\"), mdx(\"h2\", null, \"Overview\"), mdx(\"p\", null, \"Software systems have become more flexible and feature-rich. For example, the configuration file for MySQL has more than 200 configuration entries with different subentries.  As a result, configuring these systems is a complicated task and frequently causes configuration errors. Currently, in most cases, misconfigurations are detected by manually specified rules. However, this process is tedious and not scalable. In this project, we propose data-driven methods to detect misconfigurations by discovering frequently occurring patterns in configuration files. \"), mdx(\"h2\", null, \"Misconfiguration detection framework\"), mdx(\"p\", null, \"The misconfiguration detection framework adopted in this project is inspired by the research paper \\u201CSynthesizing Configuration File Specifications with Association Rule Learning\\u201D. Association rule learning is a method to discover frequently occurring patterns or associations between variables in a dataset. \"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"notebooks/images/framework.png\",\n    \"alt\": \"image alt text\"\n  })), \"Figure 1: Overview of the misconfiguration detection framework. It has two important modules: translator and learner. \"), mdx(\"ul\", {\n    \"className\": \"pf-c-list\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Translator: Translator works as a parser, translator converts raw configuration files into an intermediate representation which generally has a format of key, value, data type, frequency (k, v, \\u03C4, f)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Learner: Learner discovers frequently occurring patterns or associations between keywords in configuration files to derive rules.\"))), mdx(\"p\", null, \"Data type error detection:  In this method, we match the data type of target key with the data type information inferred from the training set. An error is reported if the matching fails.\"), mdx(\"p\", null, \"Spelling error detection: In this method, we find spelling errors by mapping lower frequency keywords to a similar higher frequency keyword. We calculated the similarity between keywords using Levenshtein distance. \"), mdx(\"h2\", null, \"Project organization\"), mdx(\"hr\", null), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-text\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"\\u251C\\u2500\\u2500 src                \\n\\n\\u2502   \\u251C\\u2500\\u2500 data\\n\\n\\u2502   \\u2502   \\u2514\\u2500\\u2500 data_downloader.py  <- Script to download the configuration file dataset\\n\\n\\u251C\\u2500\\u2500 notebooks          \\n\\n|\\t\\u2514\\u2500\\u2500 Misconfiguration_detection_framework_for_data_type_errors.ipynb <- notebook for data type error detection in configuration files.\\n\\t\\u2514\\u2500\\u2500 Misconfiguration_detection_framework_for_spelling_errors.ipynb <- notebook for spelling error detection in configuration files.\"))), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"In this project, we discovered frequently occurring patterns in MySQL configuration files to detect misconfiguration. We experimented with two types of errors based on patterns in configuration files.  We detected data type errors by matching the target key data type with the data type information inferred from the training set. We detected spelling error by mapping lower frequency keyword to a similar higher frequency keyword. We can easily extend this to include other types of errors based on patterns in the configuration files. The results suggest that we can automate the misconfiguration detection task using data-driven methods for all types of key-values based configuration files. \"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"","description":null}}},"pageContext":{"id":"553ce20e-8262-5fc9-8378-853aadf5596f","slug":"README"}},"staticQueryHashes":["117426894","3000541721","3753692419"]}